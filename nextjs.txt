
				  Next.js
.............................................................................................

Software Req:

1.Node.js
2.VSCODE

Pre Knowledge:

1.Javascript
2.React fundamentals

What you are going to learn?

1.Next js UI development
2.REST api development
3.Database Programming Using Prisma ORM Framework
4.GraphQl with Apollo Framework,
5.Connecting Nextjs with Apollo Framework

............................................................................................
			Next js 
....................................................................................
What is Next?
	 Next is a flexible React framework that gives you building blocks to create fast "web applications".
         Next is react framework for building full stack web applications.

Full stack:
   End to End is one framework
  Like
   UI, Back End
   UI is react 
   Back end is also react.

What is React?
         React is JavaScript lib to build "Single Page Web applications"/SPA 


What is web app?
  Type of distributed app, deployed at server , accessed over network(internet) vi various network protocols like http,  tcp, smtp...
  
  Web apps works based on request and response model.
  Web apps are hosted on server called web server.

Web server receives request , runs a program, that program returns response to the client.


Response would be document.
=>HTML

other responses types
XML,JSON, Documents, images, videos.........

What is web app?
  Type of distributed app, deployed at server , accessed over network(internet) vi various network protocols like http,  tcp, smtp...
  
  Web apps works based on request and response model.
  Web apps are hosted on server called web server.

Web server receives request , runs a program, that program returns response to the client.

Response would be document.
=>HTML

other responses types
XML,JSON, Documents, images, videos.........

What is web and why it was created?

  Tim Berners-Lee, a British scientist, invented the World Wide Web (WWW) in 1989, while working at CERN. The web was originally conceived and developed to meet the demand for automated information-sharing between scientists in universities and institutes around the world.

The first Web browser is line mode web browser, launched in 1992.
The first web server is NeXT computer
The first web page , launched http://info.cern.ch/hypertext/WWW/TheProject.html


Technology stack:
................
1.HTML
2.Webserver - Next Computer
3.LineMode Web Browser
4.HTTP protocol.

...........................................................................................


Types of Web application:

1.Static web applications - 1989 to 1995
    Hard coded html pages, Prepared html pages kept at server, the web server will send those html pages to clients - browsers

Do you think Static web applications still exits?
  Yes!, but we don't prepare the html pages by hand.. rather we ask the server to prepare..

2.Dynamic Content generation application(1996 to till date)

 After 1995, many people thought that how we can use web for biz information system

 How to share biz information via internet?
   Generally biz data is stored in databases , how to embed database data into html pages.

 1.web server need to talk to database
 2.web server need to prepare html pages based on database records
 3.Those information must be transported to web clients.


Web server core design to get client request and send html response to the client.

Along with web server, something was introduced called "Programming language runtime"

Tech stacks:

1.CGI With C language and Perl script.
2.Java Servlets and JSP
3.Active Server pages - ASP
4.PHP


3.Web services-1998 to till date

 Rise of ECommerce, using internet and web how to exchange data between two biz organizations.
 The existing html technology was not suitable to send and receive data because html is just   user interface document language.

 We need , data to be exchanged, that's where new data model was created called 'XML'
xml based web apps called web services.

SOAP protocol was created to transfer XML based documents "SOAP based webservices"

After 2005 SOAP based web services, started failing due to mobile computing.

New Web services  were designed called "RestFull Web services"

Restfull web services were used to build any type of data formats like json,xml,pdf,html etc...


4.Client side web apps called "Single Page Web Apps"(2007 to till date)

Single page web apps are built using JavaScript at client side where as server side web services(REST apis) are used.

SPA Tech stack:
HTML 5,CSS 3, JavaScript.

Frameworks build based on SPA

1.Angular js |Angular
2.react js
3.vue js
				.....................................................................................
				React as SPA lib
.....................................................................................

Reactjs was created by Facebook , in order to build SPA applications for browsers.


Advantages of SPA:

1.Pages are created  at client side, so server load is completely removed
2.SPA reduces the lot of physical pages after deployment.
3.Clear separations of concerns.

Drawbacks of SPA:
.................

Pure client SPAs are problematic when the app is sensitive to SEO and 
Time-to concept ,This is because the browser will receive a large empty HTML page and has to wait until the JavaScript is loaded before rendering any thing.

To solve SEO Problems, new Technology was created called "SSR" - Server Side Rendering

..................................................................................
			    Server side Rendering
...................................................................................

Render: Page preparation or HTML Creation

I need SEO but at the same time, i want to use SPA as well.
 
We provide first class api to "render"  an SPA app into HTML strings on the server.

This allows server to send back already rendered HTML, allowing end users to see the content immediately while the JavaScript is being downloaded.


Hydration:
  This process is called "hydration", the app is compiled at server side and sent to the client which will be  interactive.

....................................................................................			           	Rendering Types
.....................................................................................

What is Rendering?
   Render means preparation, HTML Page preparation...


Rendering Types:
1.CSR- Client side Rendering.
   HTML Pages are prepared at client side - Pure SPA Applications
2.SSR  -Server Side rendering
   HTML Pages are prepared at server side - Dynamic Content Generation applications.

3.Hybrid Rendering /Universal rendering
   Some portion of the app is rendered at client side and some portions of the app is rendered
  at server side.

 if you want to build full ssr, you can go ahead with traditional technology such as "PHP,Java servlets,JSP,asp.x etc"

if you want to build partial ssr/hybrid rendering you can go ahead deploying the your react app on express.js server where index.html is preparted along with Search engine Meta data , client side ui is prepared at browser.

if you want to build such infrastructure, you have to build every thing manually
		but now a days you dont need, because we have hybird rendering frameworks

with lot of new features such as caching,rest api developmet,database programming etc...

			              "Next.js"

Next.js is modern framework used to build various types of web applications


.....................................................................................
		      When Rendering can happen
 		    (when html pages are prepared)
....................................................................................
1.Request time
2.Build time

1.Request time :
 When user types url 

  http://www.example.com/product--------------->Server Receives Request----Prepares Page--send   that page to client.
 Technologies : jsp,asp,php

2.Build time
    Build is nothing but, preparing app for production.. before hosting we have to prepare the   app
  During build phase, we can prepare html pages/render html pages 


SSG -  Static Site Generations:
...............................

Building web sites/apps during build phase is called SSG.

Why SSG?
  Super fast page access

Based On SSG , There is specification is available "JAM Stack"

Data changes rapidly , we need to enable request time page preparation.
.....................................................................................
			    SSR (request time) + SSG (build time)

During build process, we have to enable SSG, during runtime not for all pages we need to enable SSR (Request Time page Preparation)

....................................................
			ISR - Incremental Static Rendering
.....................................................................................

SSG - Build time or ahead of time
SSR - Request time

ISR = SSG + SSR - Build time + request time 
.....................................................................................
.....................................................................................
				What is Next.js?

  Next js is a framework that helps to build web apps of all types

 you can build Full SSR apps..
 you can build SSR With Request time
 you can build SSG with Build time -  JAM Stacks
 you can build SSR with CSR  - Server + SPA - Hybrid rendering
 you can build rest apis also - Web services

         "You cant build pure SPA apps like react with redux"

Using Next you can build 
     Pure server side apps with database access, other external api access.....


.....................................................................................
	               Next js UI layer - Next JS APP architecture
.....................................................................................
Next js uses "react core features" to build UI layer...

React core features:
1.React component driven
2.React uses data mutation techniques like props and state
3.React uses event listeners for interactions
4.React hooks


Next.js tech stack:

1.React as ui layer
2.Next does not recommend to use "redux"
3.Next uses api layer- rest api development
4.Next can talk to any database via orm frameworks...



.....................................................................................
			Next js framework and Runtime Architecture
.....................................................................................


	Next js uses "Rust based build system" where as react uses web pack build ....

What is Rust?
 It is programming language, used to build Nestjs apps. Next core engine is written in Rust only.

Next.js Compiler:
..................
 Next js Compiler is written using RUST Using SWC (Speedy Web Compiler).
https://swc.rs/docs/getting-started

SWC allows next js to transform and minify the js code for production. This replaces babel.

SWC is 20x faster than Babel, it is embedded inside next js

Turbo pack:
 Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. Turbopack can be used in Next.js in both the pages and app directories for faster local development

....................................................................................
		NEXT JS Getting Started
.....................................................................................

How to install next js and how to create app?

System Req:

1.Node.js 18 or later
2.OS - any os
3.vs code.

Installing/Create next app:
..........................

There are two ways :

1.automatic way


   We recommend starting a new Next.js app using create-next-app, which sets up everything automatically for you. To create a project, run:

npx create-next-app@latest

2.manual way

 Just create folder and app structure your self and install packages

 To manually create a new Next.js app, install the required packages:

 npm install next@latest react@latest react-dom@latest


.............................................................................................
				Next application creation types

There are two types  you can create next application.

Next.js app types

1.App router based app
   It is modern way of creating app
   Next.js version 13 and after , all apps are app router based
2.page router based app
   It is old way of creating app
   Next.js version 12 and before all apps are page router based

In both types, there are plenty of differences are there, we follow app router based only.

npx create-next-app@latest
Need to install the following packages:
create-next-app@15.2.3
Ok to proceed? (y) y

√ What is your project named? ... helloworld-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\IBM\nextjs\apps\helloworld-app.
		.............................................................................................
			        Exploring Project Structure
..............................................................................................
package.json
{
  "name": "helloworld-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "15.2.3"
  }
}

next.config.mjs

   Next.js Engine/runtime configuration

/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

Compiler Config:
............................
jsconfig.json

{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
.............................................................................................
Folders:

public
 Stores static assets such as images,fonts,documents
 public dir are accessed inside code using the base URL "/"

src/app:
   It is root folder where all source code of the next will go.

This is where all application code will go..

layout.js
page.js
global.css
page.module.css

.....................................................................................
How to run next app?

dev, build and prod

dev mode:

>npm run dev

.............................................................
		               Next.js Application Architecture
..............................................................................................
               Next.js app is server side app, so for each web page ,the html page is created.
		   "Next App is conventional over Configuration based"

conventional over configuration is a software design principle that reduces the need for explicit configuration by following sensible defaults.
file names and folder names are standard based.
filenames are predefined...like page.js , layout.js


.....................................................................................
			 React core features inside next js
.....................................................................................
1.Component:
  In react every thing is component, in next also the component driven arch is followed.

2.Props
    In react data is passed to the component via props.
    Components are created in a configurable way..

Types of Props:

1.Data as prop

   <User id={1} />

2.State as Prop -Dynamic Prop

  function User(){
    const [id,setId] = useState(1)
    return <UserDetails id={id} />
  }

3.function as Prop- Listeners as Prop

  function User(){
    const [id,setId] = useState(1)
    return <UserDetails setId={setId} />
  }

4.Component as Prop
  Component as Prop syntax we use heavily in Next.js

 Component Rendering:

function Tab(props){
   return <> {props.children} </>
}

<Tab/> - Self Closing
  This component has no children

<Tab>
    <Grid/> -  Component as Prop
<Tab>

.....................................................................................
			 Every thing is component  in Next.js
....................................................................................

Page Component:
  It is place holder component which displays ui.

Layout Component:
  It is container component which holds Page Component


   layout - parent
	  ------------------------------
          |                             |
                      Page -child       |
          |                             |
          |                             |
          |                             |
           -----------------------------

<Layout>
   <Page/>
</Layout>

How to declare components?

 1.every component must be "functional component" - No Class Component.
 2.every component (page,layout...)  must be exported using "export default" only.
 3.Every Next application must have "root layout" - src/app/layout.js
 4.Every Next application must have  "home/landing page" src/app/page.js
 5.Component Name can be any thing like HomePage,Home,MyHomePage,MyLayout etc..

			File Types


1.layout.js

  Shared UI for a segment(page/router) and its children
  if a layout.js presents inside src/app folder which is called root layout.
  every next.js app must have one layout.js which is root layout file.

2.nestedlayout -layout.js
   Shared UI for a a segement and its children
  when you define routing, that time we may or not use layout...

  root layout vs nested layout:
     root layout must have <html>,nested layout <div> or section elements (div,header,section ...)

Root Layout:

 <html>
  <head></head>
  <title>title</title> 
   <body>
	<nested Layout>Insert Page</nestedLayout>
   </body>
 </html>

3.page.js
       Unique UI of a route,meaning the page is mapped against routing like                /",index,products,users,customers


4.loading.js
   Loading UI (Spinner) for a segement and its children

5.not-found.js
   Not Found UI for a segment and for its children
   if routing is failed to map against a page, then next.js will show error page.

6.error.js
  It is used to show custom component logic errors.

Note:
  All error files are represented by "React Error Boundary".

7.global-error.js
  It is to show app level errors.

8.template.js:
   Specailzied re-rendered layout UI.

9.route.js
   you can write "restfull" web services".

10.default.js
    Fallback UI for "Parrel Routes"

.............................................................................................
  				    Routing
       			 	Pages and Layouts
.............................................................................................

In Next js application routing is core concept, every thing is built on the top of routing only.

In Next js routing is in built.

The Skeleton of every next app is routing only.

Routing is mapped against folders and files only...

Inside the app directory, "folders" are used to define routes...


Routing:
 menu based navigation or navigation.

IN SPA , routing is controlled by browser using history and location objects

react , angular,vue these frameworks provides abstraction on these objects.

react has react router.

in next js routing is completely in built - routing is based on folders 
urls are mapped against folder


src/app   ------------- (page.js) / (index route)

src/app/card/   (page.js) ---------- /card

src/app/dashboard  (page.js)   -- /dashboard

src/app/dashboard/settings/   (page.js)    - /dashboard/settings



src/app
  /folder -it becomes route

src/app/ ---- index route or home route.

Url pattern(Routing Pattern)

http://localhost:3000/  -----mapped against------src/app/page.js

Route Segment:

  Each folder inside "src/app" represents a "route segment" that maps to a "URL" segement. in order to create route you can nest folders inside each other.


URL Pattern:

localhost:3000 /    
	       |
            Root segment

Segment means part of url.


localhost:3000 /     dashboard /settings
		|       |            |              
	Root segment  Segment   leaf Segment
.............................................................................................
			  Nested Routing and Segments
.............................................................................................

Steps: Create new App
>npx create-next-app@latest
Need to install the following packages:
create-next-app@15.2.4
Ok to proceed? (y) y

√ What is your project named? ... core-routing
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*

...............................................................................................
				Nested Folders and Routing
...............................................................................................

							Nested Folders and Routing
..........................................................................................................................................................

src/app/welcome/page.js

export default function WelcomePage(){
    return <h1>Welcome Page</h1>
}

http://localhost:3000/welcome -----> it will show page.js content of welcome/page.js

src/app/about/page.js

export default function About(){
    return <h2>About</h2>
}
http://localhost:3000/about - it will show page.js and content of about/page.js

Nested Layout:
  
src/app/layout.js - Root Layout.

 Every Next app must have one single root layout.	

src/app/welcome/layout.js  -Nested layout.
//nested layout.

export default function WelcomeLayout({ children }) {
    return <div id="welcome layout">
        {children}
    </div>
}

Note:
 inside nested folder, layout.js is optional but inside root folder layout.js is required
 page.js is required for every folder.

.............................................................................................................................................................
				  Deep Nesting
................................................................................................................................................................................................

Dashboard:

src/app/dashboard/layout.js
export default function DashboardLayout({ children }) {
    return <div id="dashboardLayout">
        {children}
    </div>
}
src/app/dashboard/page.js
export default function Dashboard(){
    return <h1>Dashboard Page</h1>
}

src/app/dashboard/settings/layout.js
export default function SettingsLayout({ children }) {
    return <div id="settingsLayout">
        {children}
    </div>
}
src/app/dashboard/settings/page.js
export default function Settings() {
    return <>
        <h1> Settings</h1>
    </>
}

src/app/dashboard/settings/password/layout.js
export default function PasswordLayout({ children }) {
    return <div id="passwordLayout">
        {children}
    </div>
}

src/app/dashboard/settings/password/page.js
export default function Password(){
    return <h2>Password Page</h2>
}
...............................................................................................
..............................................................................................................................................................
		Folder is created what if the page.js is not created - not-found.js
...............................................................................................................................................................
eg:

src/app/profile

http://localhost:3000/profile

404
This page could not be found.

if there is no page.js , then next will show the error page automatically which is mapped against not-found.js.

if you dont want default error page and its content, then you can override "not-found.js"

src/app/not-found.js
export default function NotFound() {
    return <h1>Oops,Something went Wrong</h1>
}
............................................................................................
				 template.js
.............................................................................................

layout.js and template.js are used to structure pages, that means both are same but they serve different purposes.

src/products/layout.js
export default function ProductsLayout({children}){
    return <div  id="productsLayout">
        {children}
    </div>
}

src/products/page.js

export default function Products(){ 
    return <h1>Products Page</h1>
}

template.js:
export default function ProductTemplate({ children }) {
    return <div id="productTemplate">
        {children}
    </div>
}

layout:
.......
1.persistent ( permenant ) across navigation
2.Used to wrap multiple pages under the same structure
3.Statefull - maitains state between page transitions
4.Only renders once per route segement.

Template:
1.Re-renders on every navigation
2.Used when pages need fresh instances of UI.
3.Stateless- does not persist state across transitions
4.Works like layout.js but creates a new DOM structure every time.

When to use layout and template?

Use layout for global structures - headers, footers,sidebars
Use template when pages need re-initalization on every navigation , which is best for Animations,Unique page Reloads.

Template and Layout:
   You can keep both template and layout together, but template is more dynamic where as layout is static.
				 Public Access Route
................................................................................................................................................................................................
if you have different name other than page.js, it will not be available for public access.

app/settings/config.js

http://localhost:3000/settings/config - It will throw error..

.....................................................
		 	Component Driven Archiecture
....................................................................................................................................................

Layout is container, Page is mapped against route segment, which displays UI.

Can Page Hold other Components?

    Layout
          | 
       Page
            |
 UserProfile
     |
    UserList
      |
      UserItem

npx create-next-app@latest
√ What is your project named? ... next-components
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*

Co-location:

     In addition to special files, you have the option to colocate your own files (e.g. components, styles, tests, etc) inside folders in the app directory.

src/app/profile/components/profileItem.js

export const ProfileItem = ({ profile: { name, email } }) => {
    return <>
        {/* <h2>{profile.name} {profile.email}</h2> */}
        <h2>{name} {email}</h2>
    </>
}


src/app/profile/components/profileList.js
import { ProfileItem } from './profileItem'

export const ProfileList = (props) => {
    return <div>
        {
            props.profiles.map(profile => {
                return <div key={profile.id}>
                    {/* <h2>{profile.name} {profile.email}</h2> */}
                    <ProfileItem profile={profile} />
                </div>
            })
        }
    </div>
}

src/app/profile/page.js

import { ProfileList } from "./components/profileList";
import { PROFILES } from "./mock-data/profile";

export default function Profile() {
    return <>
        <ProfileList profiles={PROFILES} />
    </>
}

src/app/profile/layout.js
export default function ProfileLayout({ children }) {
    return <div>
        {children}
    </div>
}

TasK: Just think of other components , like todos,products..


.............................................................................................
			     Component Types and Rendering Types
.....................................................................................

Rendering is nothing but page preparation (html creation).

How to create html and where to create Html?

Where:
 rendering can take place in the server or on the client.

When:
  At Server side:
   It can happen either ahead of time at build time.
   or on every Request at runtime.

With next js , two types of rendering methods are available.

1.Server-side rendering
   1.0. Request time
   1.1. Static site Generation - build time
   1.2. ISR - Incremental Static rendering - first Build time and later runtime.

2.Client-side Rendering
   Preparing portion of page at client side , which is similar to SPA Apps.


Component types:
 Based on Rendering, we can classify the component into two category.

1.Server Component
   Server components are rendered at server side
2.Client components
   Clients components are rendered at client side

      By default all components are "Server Rendered Components"

   page,layouts,templates,notfound,loading,default all are server components only

Even When create custom components

export default function Greet(props) {
     return <>
        <h1>{props.message}</h1>
     </>
}
.....................................................................................
			 	Client Component
....................................................................................

src/app/review/components/review.jsx
import { useState } from "react"

const Review = props => {
    const [like, setLike] = useState(0)
    return <div>
            <h1>Like {like}</h1>
    </div>
}
export { Review }

Ecmascript file had an error
> 1 | import { useState } from "react"
    |          ^^^^^^^^
  2 |
  3 | const Review = props => {
  4 |     const [like, setLike] = useState(0)

You're importing a component that needs `useState`. This React hook only works in a client component. To fix, mark the file (or its parent) with the `"use client"` directive.

 Learn more: https://nextjs.org/docs/app/building-your-application/rendering/client-components

Why this error?

If any component having "hooks,listners,state",then it cant be compiled at server, now need to tell to the next js compiler, you have to compile or render this code in client side.

How to tell?
 we have to use a directive.

Directive is instruction to the compiler.

"use client" - directive

eg:
src/app/review/components/review.jsx

'use client'

import { useState } from "react"
const Review = props => {
    const [like, setLike] = useState(0)
    return <div>
        <h1>Like {like}</h1>
        <button onClick={() => {
            setLike(like + 1)
        }}>+</button>
    </div>
}
export { Review }

src/app/review/page.js
import { Review } from "./components/Review";

export default function ReviewPage(){
    return <div>
        <Review/>
    </div>
}
How to know the client component?

if component has 

1.useState hook
2.Any listener
3.useEffect hook
4.Browser apis
5.state declaration
..............................................................................................
				Patterns for client and server components
.............................................................................................

1.Server component uses another Server Component
   inside layout.js we use page.js
   inside page.js we use about.jsx 

2.Server component uses client component

3.Client component uses another server component

4.Client component uses another client component



2.Server component uses client component

Server:

src/app/reviews/page.js
import { Like } from './components/like'

export default function ReviewPage() {
    return <div>
        <h1>Review Page</h1>
        <Like />
    </div>
}

Client:
src/app/reviews/components/likes.jsx

'use client'
import { useState } from "react"
export const Like = props => {
    const [value, setValue] = useState(0)

    const onLike = () => {
        setValue(value + 1)
    }
    return <>
        <h1>Like {value}</h1>
        <button onClick={onLike}>Like</button>
    </>
}

Note:
 if server uses client, the client component must be marked with "use client" directive

3.Client component uses another server component
2.Server component uses client component

Server:

src/app/reviews/page.js
import { Like } from './components/like'

export default function ReviewPage() {
    return <div>
        <h1>Review Page</h1>
        <Like />
    </div>
}

Client:
src/app/reviews/components/likes.jsx

'use client'
import { useState } from "react"
export const Like = props => {
    const [value, setValue] = useState(0)

    const onLike = () => {
        setValue(value + 1)
    }
    return <>
        <h1>Like {value}</h1>
        <button onClick={onLike}>Like</button>
    </>
}

Note:
 if server uses client, the client component must be marked with "use client" directive
...........................................................................................
		3.Client component uses another server component
............................................................................................
//server component
src/app/reviews/components/comments.jsx
//server component
export const Comments = ()=> {
    return <>
     <h1>Comments  Server Compoent</h1>
    </>
}

//client component
src/app/reviews/components/dislike.jsx


'use client'

import { useState } from "react"
import { Comments } from "./comments"

export const Dislike = ()=> {
 const [value,setValue]= useState(0)
 return <>
     <h1>Dislike-Client Component</h1>
      <h2>Value  {value}</h2>
      {/* Server component */}
      <Comments/>
 </>

}

src/app/reviews/page.js
import { Dislike } from './components/dislike'

export default function ReviewPage() {
    return <div>
        <h1>Review Page</h1>
        <Dislike/>
    </div>
}

if client uses another server component,server component automatically becomes client component.

                 When we use this pattern we loose server rendering.

In the above code comments component runs in the client only.

What if "client uses server component" but at the same time, i dont want to loose server rendering feature?

Solution:

  Pass Server Component as Prop to Child  component.
...........................................................................................
		3.Client component uses another server component
............................................................................................
//server component
src/app/reviews/components/comments.jsx
//server component
export const Comments = ()=> {
    return <>
     <h1>Comments  Server Compoent</h1>
    </>
}

//client component
src/app/reviews/components/dislike.jsx


'use client'

import { useState } from "react"
import { Comments } from "./comments"

export const Dislike = ()=> {
 const [value,setValue]= useState(0)
 return <>
     <h1>Dislike-Client Component</h1>
      <h2>Value  {value}</h2>
      {/* Server component */}
      <Comments/>
 </>

}

src/app/reviews/page.js
import { Dislike } from './components/dislike'

export default function ReviewPage() {
    return <div>
        <h1>Review Page</h1>
        <Dislike/>
    </div>
}

if client uses another server component,server component automatically becomes client component.

                 When we use this pattern we loose server rendering.

In the above code comments component runs in the client only.


What if "client uses server component" but at the same time, i dont want to loose server rendering feature?

Solution:

  Pass Server Component as Prop to Child  component.

Server:
src/app/client/components/myserver.jsx
export default function MyServer(){
    return <>
        <h1>Server Compoent</h1>
    </>
}

Client
src/app/client/components/myclient.jsx
'use client'

export const MyClient = (props) => {

    return <div>
        <h1>Client Component</h1>
        {props.children}
    </div>
}


Page
src/app/client/page.js
import { MyClient } from "./components/myclient";
import MyServer from "./components/myserver";

export default function ClientComponentPage(){
    return <div>
            <MyClient>
                {/* Pass server as prop */}
                <MyServer/>
            </MyClient>
    </div>
}
...............................................................................................
				....................................................................................
		3.Client Compoent uses another client Component
.....................................................................................


Page:
src/app/counter/page.js
import Counter from "./components/counter";

export default function CounterPage(){
    return <div>
        <h1>Counter Page</h1>
        <Counter/>
    </div>
}

src/app/counter/counter.jsx

'use client'

import Increment from "./increment"

export default function Counter() {

    return <>
        <h1>Counter Component</h1>
        <Increment/>
    </>
}

src/app/counter/increment.jsx


'use client'
import { useState } from "react"

export default function Increment() {
  const [value,setValue] = useState(0)
    return <>
        <h1>Increment Value {value}</h1>
    </>
}

Note :

If client component uses another client component, that another client component no need to use 'use client' directive.

Note :

If client component uses another client component, that another client component no need to use 'use client' directive.

This would be very useful when we use thrid party ui components into next js
.....................................................................................

Eg:
How to use react carbon lib

Steps:

1.npm install @carbon/react

2.create client component

src/app/clientcomponents/MyButton.jsx
'use client'

import { Button } from '@carbon/react';

export function MyButton() {
    return <>
        <Button kind="danger">
            Button
        </Button>

        <Button kind="danger--tertiary">
            Tertiary Danger Button
        </Button>

        <Button kind="danger--ghost">
            Ghost Danger Button
        </Button>
    </>
}

3.Use that client component inside another client component or server component

import { Counter } from "./components/counter";
import { MyButton } from "./components/MyButton";

export default function CounterPage(){
    return <div>
        <Counter/>
        <hr/>
        <MyButton/>
    </div>
}

Task:
 Build simple shopping cart using client components

Features
1.Loads cart items from localStorage when page loads
2.Add new Items to the cart dynamically
3.Removes items with a delete button
4.saves the cart back to the localStorage whenever it changes
5.persist data even after page refresh.

eg:

src/app/shop/page.js

import Cart from "./cart";

export default function ShopPage() {
    return <div>
        <h1>🛒 Simple Shopping Cart</h1>
        <Cart />
    </div>
}

src/app/shop/cart.js

"use client";
import { useState, useEffect } from "react";

export default function Cart() {
  const [cart, setCart] = useState([]);

  // Load cart from localStorage on first render
  useEffect(() => {
    const storedCart = JSON.parse(localStorage.getItem("cart")) || [];
    setCart(storedCart);
  }, []);

  // Save cart to localStorage whenever it changes
  useEffect(() => {
    localStorage.setItem("cart", JSON.stringify(cart));
  }, [cart]);

  // Add item to cart
  const addItem = (item) => {
    setCart([...cart, item]);
  };

  // Remove item from cart
  const removeItem = (index) => {
    setCart(cart.filter((_, i) => i !== index));
  };

  return (
    <div style={{ padding: "20px", maxWidth: "400px", margin: "auto", border: "1px solid #ddd", borderRadius: "10px" }}>
      <h2>🛍 Shopping Cart</h2>
      <button onClick={() => addItem({ id: Date.now(), name: "Product " + (cart.length + 1) })}>
        ➕ Add Random Product
      </button>
      <ul>
        {cart.map((item, index) => (
          <li key={item.id} style={{ display: "flex", justifyContent: "space-between", padding: "5px 0" }}>
            {item.name}
            <button onClick={() => removeItem(index)}>❌</button>
          </li>
        ))}
      </ul>
      {cart.length === 0 && <p>🛒 Your cart is empty</p>}
    </div>
  );
}
...............................................................................................
........................*******************.................................................
		  Advanced Routing - Linking and Navigation
..............................................................................................

There are four ways to navigate between routes in Next.js

- Using the <Link> Component (Client Component)
- Using useRouter hook (client Component)
- Using redirect function (Server component)
- Using the native browser History API (client)

Navigation can happen  in two places

1.Server side redirection/navigation
   Redirection is controlled by Server
2.Client Side Redirection/Navigation
   Redirction is controlled by browser

Server Redirection:
1.redirect function
2.permantRedirect function
3.routeConfig file
4.API redirections - NextReponse.redirect


Client Side Naviation:
1.Link component
2.useRouter Hook
3.Browser Native History API.


>npx create-next-app@latest
√ What is your project named? ... linking-navigation
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*

Where do you add menu bar for entire application?

You have to add in the master layout.


src/app/layout.js
import { Inter } from "next/font/google";
import Link from "next/link";
// import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <div id="header">
          <h1>Header</h1>
          <hr />
          {/* Nav Bar */}
          <nav>
            <ul>
              <li> <Link href={{ pathname: '/about' }}>About</Link> </li>
              <li> <Link href={{ pathname: '/products' }}>Products</Link> </li>
              <li> <Link href={{ pathname: '/customercare' }}>Customer Care</Link> </li>
            </ul>

          </nav>
        </div>
        {children}
        <div id="footer">
          <h3>footer</h3>
        </div>
      </body>
    </html>
  );
}


src/app/about/page.js

export default function AboutPage({ children }) {
    return <>
        <p>
        International Business Machines Corporation (using the trademark IBM), nicknamed Big Blue,[6] is an American multinational technology company headquartered in Armonk, New York and present in over 175 countries.[7][8] IBM is the largest industrial research organization in the world, with 19 research facilities across a dozen countries, having held the record for most annual U.S. patents generated by a business for 29 consecutive years from 1993 to 2021.[9][10][11]

IBM was founded in 1911 as the Computing-Tabulating-Recording Company (CTR), a holding company of manufacturers of record-keeping and measuring systems. It was renamed "International Business Machines" in 1924 and soon became the leading manufacturer of punch-card tabulating systems. During the 1960s and 1970s, the IBM mainframe, exemplified by the System/360, was the world's dominant computing platform, with the company producing 80 percent of computers in the U.S. and 70 percent of computers worldwide.[1
        </p>
    </>
}

src/app/products/page.js


export default function ProductsPage(){
    return <div>
          <h1>Product Page</h1>
    </div>
  }

src/app/customercare/page.js


export default function CustomerCare(){
    return <div>
          <h1>Customer Page</h1>
    </div>
}
.............................................................................................
			 How to create separate nav bar - Server component
..............................................................................................

src/app/componenents/navbar.jsx
import Link from "next/link";

export default function NavBar() {
    return <nav>
        <ul>
            <li>
                <Link href={{ pathname: '/' }} >Home</Link>
            </li>
            <li>
                <Link href={{ pathname: '/about' }} >About</Link>
            </li>
            <li>
                <Link href={{ pathname: '/products' }} >Products</Link>
            </li>
        </ul>
    </nav>
}

src/app/components/footer.jsx

export default function Footer(){
    return <footer>
        <h3>Footer Goes here</h3>
    </footer>
}

src/app/layout.js
import Footer from "./components/footer";
import NavBar from "./components/navbar";
import "./globals.css";


export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body >
        {/* Nav Bar  */}
        <NavBar />
        <hr />
        {/* Page content */}
        {children}
        {/* Footer Content */}
        <Footer />
      </body>
    </html>
  );
}

.....................................................................................
					Active Links
.......	..............................................................................

How to enable active link feature?

you can use hook "usePathname()" to determine if link is active or not.

For example to add a css class to the active link, you can check the current pathname matches the of the link.

Syntax:
import {usePathname} from 'next/navigation'

const pathname = usePathname()

Link className={`link ${pathname=== '/' ? 'active' : ''}`}>Home</Link> 

src/app/link.css
.active {
    color: rgb(0, 255, 26);
    background-color: rgb(62, 37, 39);
}

src/app/components/navbar.jsx
'use client'

import Link from "next/link";
import { usePathname } from "next/navigation";
import '../link.css'
export default function NavBar() {
    const pathname = usePathname()
    return <nav>
        <ul>
            <li>
                <Link className={`link ${pathname === '/' ? 'active' : ''}`} href={{ pathname: '/' }} >Home</Link>
            </li>
            <li>
                <Link className={`link ${pathname === '/about' ? 'active' : ''}`} href={{ pathname: '/about' }} >About</Link>
            </li>
            <li>
                <Link className={`link ${pathname === '/products' ? 'active' : ''}`} href={{ pathname: '/products' }} >Products</Link>
            </li>
        </ul>
    </nav>
}

src/app/layout.js
import Footer from "./components/footer";
import NavBar from "./components/navbar";
import "./globals.css";


export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body >
        {/* Nav Bar  */}
        <NavBar />
        <hr />
        {/* Page content */}
        {children}
        {/* Footer Content */}
        <Footer />
      </body>
    </html>
  );
}
....................................................................................
				 useRouter Hook
...................................................................................

useRouter hook allows you programmetically change route from client components.

src/app/components/DashboardNavigator.jsx

'use client'

import { useRouter } from "next/navigation"

export function DashBoardNavigator() {
    const router = useRouter()
    return <>
        <button onClick={() => {
            router.push('/')
        }}>GoToDasbhoard</button>
    </>
}

src/app/dashboard/page.js

import DashboardNavigator from "../components/DashboardNavigator";

export default function DashboardPage(){
    return <>
        <DashboardNavigator/>
    </>
}

src/app/components/navbar.jsx
'use client'

import Link from "next/link";
import { usePathname } from "next/navigation";
import '../link.css'
export default function NavBar() {
    const pathname = usePathname()
    return <nav>
        <ul>
            <li>
                <Link className={`link ${pathname === '/' ? 'active' : ''}`} href={{ pathname: '/' }} >Home</Link>
            </li>
            <li>
                <Link className={`link ${pathname === '/about' ? 'active' : ''}`} href={{ pathname: '/about' }} >About</Link>
            </li>
            <li>
                <Link className={`link ${pathname === '/products' ? 'active' : ''}`} href={{ pathname: '/products' }} >Products</Link>
            </li>
            <li>
                <Link className={`link ${pathname === '/dashboard' ? 'active' : ''}`} href={{ pathname: '/dashboard' }} >Dashboard</Link>
            </li>
        </ul>
    </nav>
}
..............................................................................................
..............................................................................................
			Advanced Routes - Dynamic Routes

What is Dynamic Route?
   When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time.

/users
/users/1
/posts/comments/1
	
How to create dynamic route?
Convention:
   A dynamic segment can be created by wrapping a folder's name in square brackets.
  [folderName]
   eg:
     [id] or [city] or [slug]

>npx create-next-app@latest
√ What is your project named? ... dynamic-routes
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*

..............................................................................................
				Building Master details Page
...............................................................................................

1.Using mock data
2.Using api call

.....................................................................................
			 Building Master detail page
.....................................................................................

Ways to build:
1.Using mock data
2.Using api call


Using Mock data:

src/app/todos/page.js
// import { TODOS } from "../mock-data/todos";
import { TODOS } from "@/app/mock-data/todos" //import alise

import Link from "next/link";

export default function TodosPage() {
    return <div>
        <ul>
            {
                TODOS.map(todo => {
                    return <li key={todo.id}><span>
                        <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                    </span></li>

                })
            }
        </ul>
    </div>
}

src/app/todos/[id]/page.js
import { TODOS } from "@/app/mock-data/todos"

export default async function TodosDetailsPage(props) {
    const todosId = await props.params.id
    const todo = TODOS.find(todo => todo.id == todosId)
    return <div>
        <h1> {todosId} details</h1>
        <h2>{todo.title}</h2>
        <h3>{todo.status ? 'done' : 'not done'}</h3>

    </div>
}
.....................................................................................
Using Api:
..........

src/app/photos/page.js
import Link from "next/link"

//function to fetch data
export async function fetchPhotos() {
    try {
        const url = 'https://jsonplaceholder.typicode.com/photos'
        const response = await fetch(url)
        const photos = await response.json()
        return photos
    }
    catch (err) {
        console.log(err)
    }
}

export default async function PhotosPage() {

    const photos = await fetchPhotos()

    return <>
        <ul>
            {
                photos.map(photo => {
                    return <li key={photo.id}>
                        <Link href={`/photos/${photo.id}`}>{photo.title}</Link>
                    </li>
                })
            }
        </ul>
    </>
}

src/app/photos/[id]/page.js

export async function fetchPhotosById(id) {
    const url = `https://jsonplaceholder.typicode.com/photos/${id}`
    const response = await fetch(url)
    const photo = await response.json()
    return photo
}

export default async function PhotosDetailPage(props) {
    const id = await props.params.id
    const photo = await fetchPhotosById(Number(id))


    return <div>
        <h1>Photos Details Page</h1>
        <h2>Photo Id :{photo.id} </h2>
        <h3>AlbumId : {photo.albumId}</h3>
        <p>{photo.title}</p>
        <p>{photo.thumbnailUrl}</p>
    </div>
}

............................................................................................
				Styling-CSS,Fonts,Images
.............................................................................................

CSS:
1.Global CSS
2.CSS Modules
3.CSS Framworks
  ->Tailwind framwork
  ->bootstrap
  ->SASS
4.CSS in js

>npx create-next-app@latest
√ What is your project named? ... styling-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*


Global css:
 You can use global css to apply style across the application.

To use global css,create a new css file, inside src/app/globals.css

@tailwind base;
@tailwind components;
@tailwind utilities; 

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
} */

you have to import in root layout /app/layout.js to apply styles to every route in the application.

import "./globals.css";


export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        {children}
      </body>
    </html>
  );
}

Tailwind css:
.............

if you want to integrate tailwind

steps:
1.you have to install tailwind

 npm i  -D tailwindcss @tailwindcss/postcss postcss

2.configure tailwind framework with next js app

postcss.config.mjs

const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

3.tailwind configuration
tailwind.config.mjs
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
      },
    },
  },
  plugins: [],
};
.....

4.integrate tailwind with globals.css

@import 'tailwindcss'

eg;
Designing Simple Card layout:

src/app/components/Card.jsx
export function Card({ title, description }) {

    return <div className="max-w-sm rounded overflow-hidden shadow-lg bg-white">
        <div className="px-6 py-4">
            <div className="font-bold text-xl mb-2">{title}</div>
            <p className="text-gray-700 text-base">{description}</p>
        </div>
    </div>
}

import { Card } from "./components/card"

export default function Home() {
  //card data
  const cardData = [{
    title: 'Card-1',
    description: 'This is first card'
  },
  {
    title: 'Card-2',
    description: 'This is second card'
  }, {
    title: 'Card-3',
    description: 'This is third card'
  },
  {
    title: 'Card-3',
    description: 'This is third card'
  },
  {
    title: 'Card-3',
    description: 'This is third card'
  },
  {
    title: 'Card-3',
    description: 'This is third card'
  }
  ]

  return <div className="p-10">
    <h1 className="text-3xl font-bold mb-6">Card Layout</h1>
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
      {
        cardData.map((card, index) => {
          return <Card key={index} title={card.title} description={card.description} />
        })
      }
    </div>
  </div>
}
.............................................................................................
				CSS Modules
...........................................................................................
Module Name:

YourName.module.css

eg:

src/app/profile/profile.module.css
.profile {
    max-width: 400px;
    margin: 0 auto;
    padding: 20px;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    background-color: #ffffff;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.profileImage {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    margin-bottom: 16px;
    object-fit: cover;
}

.name {
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 8px;

}

.bio {
    font-size: 1rem;
    color: #4a5566;
    line-height: 1.5;

}

src/app/profile/components/Profile.jsx
import styles from '../profile.module.css'

export function Profile({ name, bio, imageUrl }) {
    console.log(styles)
    return <div className={styles.profile}>
        <h1 className={styles.name}>{name}</h1>
        <p className={styles.bio}>{bio}</p>
    </div>
}

src/app/profile/page.js
import { Profile } from "./components/Profile";

export default function ProfilePage() {
    const profile = {
        name: 'Subramanian Murugan',
        bio: 'Next.js Trainer | Micro services Consultant | Open Source Contributor'
    }
    return <div className="flex items-center justify-center min-h-screen bg-gray-100">
        <Profile name={profile.name} bio={profile.bio} />
        <Profile name={profile.name} bio={profile.bio} />
        <Profile name={profile.name} bio={profile.bio} />
    </div>
}
.............................................................................................
				External Stylesheets
.............................................................................................

Steps:
1.install bootstrap
   npm i -D bootstrap
2.import in the root layout

src/app/layout.js

import 'bootstrap/dist/css/bootstrap.css'


How to handle Remote Images?

import Image from "next/image"

export default function Nature() {
    return <div>
        {/* Remote Image */}
        <Image src="https://via.placeholder.com/150/d32776" alt="Picture of something" width={500} height={500} />
    </div>
}

After adding, you will get compile time error

Error: Invalid src prop (https://via.placeholder.com/150/d32776) on `next/image`, hostname "via.placeholder.com" is not configured under images in your `next.config.js`
See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host

if you are accessing remote images, you must configure the location in next.config.js


next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
    images: {
        remotePatterns: [{
            protocol: 'https',
            hostname: 'via.placeholder.com',
            port: '',
            pathname: '/150/**'
        }      
    
    ]
    }
};

export default nextConfig;


import Image from "next/image"

export default function Nature() {
    return <div>
           {/* Remote Image */}
        <Image src="https://via.placeholder.com/150/d32776" alt="Picture of something" width={500} height={500} />


    </div>
}

..............................................................................................
				Fonts
.............................................................................................

By default Next js supports google fonts.

import { Inter } from "next/font/google";
import "./globals.css";

//inter font configuration
const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
Task:
 You have to build master details page

 Master page must have card layout.

 Detail page must have full information with layouts.

Data Url:
https://fakestoreapi.com/products

1.Using css with proper layouts.

....................................................................................
					Data Fetching
....................................................................................
Data fetching is nothing but talking to apis particular REST API Or GraphQL api / databases

Next app can fetch data either external end points or internal endpoints, next provides feature to build Rest API

Patterns In Data fetching:
..........................

Page Can talk to External rest api directly

1.Next Page----------------------------->External API
Page can talk to external api directly

2.NextPage-------------NextApi------------>External API
Page can talk to Next API which intern calls external API.

3.Page can talk to Next API which talks to Database

NextPage----------->NextApi------------>Databases
.............................................................................................
Types of Data fetching:

1.Server side data fetching
2.Client side data fetching.

Server side data fetching:

=>Whenever possible , we recommend fetching data on the server,This allows you to
 Have direct access to back end data resources(eg.databases)

=>Keep your application more secure by preventing sensitive information, such as access tokens and API Keys, from being exposed to the client.

=>Perform multiple data fetches with single round-trip instead of multiple individual requests on the client.

=>Reduce client-server waterfalls.

=>Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance.

			"Fetching Data Where It's Needed"

If you need to use the same data (e.g. current user) in multiple components in a tree, you do not have to fetch data globally, nor forward props between components. Instead, you can use fetch or React cache in the component that needs the data without worrying about the performance implications of making multiple requests for the same data.



Parent - Layout  - apicall url eg fetch('/api/customers')
   |
   child  - Layout -apicall sameurl -fetch('/api/customers')
     |
     child -Layout -apicall sameurl -fetch('/api/customers')
       |
      child -Layout -apicall sameurl -fetch('/api/customers')
        |
        child- Page -apicall sameurl -fetch('/api/customers')

.....................................................................................
		  	Server side data fetching using "fetch" api
.....................................................................................

Fetching data on the server with fetch:
.......................................

Next.js extends the native "fetch" Web API to allow you to configure the caching and revalidating behavior for each fetch request on the server.

React extends fetch to automatically memoize fetch requests while rendering a React component tree.

There are four places You can use fetch:
1.Server components
2.Client Components
3.Route Handlers,REST API
4.Server Actions

You can use fetch with async/await in "Server Components", in "Route Handlers", and in "Server Actions".

..............................................................................................
>npx create-next-app@latest
√ What is your project named? ... data-fetching
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*


....................................................................................
	    	Data Fetching from external API using "fetch" api
.....................................................................................
Server component:

src/app/todos/page.js

//data fetching in server component using fetch 
export async function fetchTodos() {
    try {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        const response = await fetch(url)
        return response.json()
    }
    catch (err) {
        return err
    }

}

export default async function TodosPage() {
    const todos = await fetchTodos()
    return <>
        <h1>Todos Page</h1>
        <ul>
            {todos.map(todo => <li key={todo.id}>{todo.title}</li>)}
        </ul>
    </>
}
.....................................................................................
		  Server side data fetching using  "third party" api-axios
.....................................................................................

You can use any third party ajax api to call apis from next application but which is not recommended, because other apis will not have features such as caching,revalidation,request memoziation, we have to write extra code.

.....................................................
			   Data fetching in Client components-Using fetch api
..............................................................................................
Note: 
    fetching in client component mostly not recommended but still we can..

src/app/posts/components/FetchPost.jsx

'use client'

import { useEffect, useState } from "react"

export default function FetchPost() {
    const [posts, setPosts] = useState([])
    useEffect(() => {
        async function fetchPostDetails() {
            const url = 'https://jsonplaceholder.typicode.com/posts'
            const response = await fetch(url)
            const posts = await response.json()
            console.log('client')
            setPosts((myposts) => {
                return posts.concat(myposts)
            })
        }

        fetchPostDetails();


    }, [])

    return <>
        <h1>Posts</h1>
        <ul>
            {
                posts.map(post => {
                    return <li>
                        <span>{post.title}</span>
                    </li>
                })
            }
        </ul>
    </>
}

src/app/posts/page.js
import FetchPost from "./components/FetchPost"

export default function PostPage(){
    return <>
      <FetchPost/>
    </>
}

Using "fetch" api  in client component is not recommended, the reason is which has no any caching feature is enabled, so fetch must be used only in server components/server side.

what if i want to write client side data fetching with performance?

 Dont use 'fetch' api

We have third party lib which internally wraps fetch only with caching features

....................................................................................
		       Data Fetching in Client Components using SWR API
.....................................................................................

what is SWR?
 The name “SWR” is derived from stale-while-revalidate, a HTTP cache invalidation strategy popularized by HTTP RFC 5861. SWR is a strategy to first return the data from cache (stale), then send the fetch request (revalidate), and finally come with the up-to-date data.

SWR is wrapper for fetch api only.

Why SWR
1.Client side caching by default
2.Cache revalidation by default
3.You dont need to write hooks like useEffect,useState,
4.You get data,error,loading flags

npm i swr

rc/app/components/PostsClientUsingSWR.jsx

'use client'
import useSWR from "swr"

function fetcher(...args) {
    return fetch(...args).then(res => res.json())
}

export default function FetchPostsUsingSWR() {
    const url = 'https://jsonplaceholder.typicode.com/posts'
    const { data, error, isLoading } = useSWR(url, fetcher)
    if (error) {
        return <div>
            <h1>Failed To Return</h1>
        </div>
    }
    if (isLoading) {
        return <h1>Loading...</h1>
    }
    return <ul>
        {
            data.map(post => {
                return <h2>{post.title}</h2>
            })
        }
    </ul>
}		
	
src/app/posts/page.js
import FetchPost from "@/app/components/FetchPosts";
import FetchPostsUsingSWR from "@/app/components/PostsClientUsingSWR"

export default function PostPage(){
    return <div>
        <h1>Post Page Fetching Data from the Client Side</h1>
        {/* <FetchPost/> */}
        <FetchPostsUsingSWR/>
    </div>
}

............................................................................................
	              Data fetching using Route Handler
	 	   (Rest api development and Integregation)
....................................................................................

Next api provides api layer in order to build rest apis

REST api can be used to write rest api which may talk to databases or external rest api or Graphql api or microservices

Route Handler:
  Route handlers are used to create api in next

File Name:
 route.js

src/app/todos/
   page.js
   layout.js
   route.js - it is not recommended to write like this

src/app/api/todos
    route.js
    [id]/
     route.js

url pattern
 /api/todos 
 /api/posts
 /api/products



npx create-next-app@latest
√ What is your project named? ... rest-api
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*


eg:
src/api/welcome/route.js
import { NextResponse } from "next/server";

export async function GET(req) {
    return NextResponse.json({ message: 'Hello' })
}

Testing:
http://localhost:3000/api/welcome

Dynamic parameters: Todos

src/app/api/todos/route.js
import todos from "@/app/mock-data/todos";
import { NextResponse } from "next/server";

export async function GET(request){
    return NextResponse.json(todos)
}

src/app/api/todos/[id]/route.js
import todos from "@/app/mock-data/todos";
import { NextResponse } from "next/server";

export async function GET(request, { params }) {
    const id = (await params).id
    const response = todos.filter(todo => todo.id === parseInt(id))
    if (response.length === 0) {
        return NextResponse.json({ message: 'No Todos Found' })
    }
    return NextResponse.json(response)
}

............................................................................................
				Sending payload

src/app/api/todos/route.js
import todos from "@/app/mock-data/todos";
import { NextResponse } from "next/server";

export async function GET(request) {
    return NextResponse.json(todos)
}

//POST
export async function POST(request) {
    //read payload
    const payload = await request.json()
    return NextResponse.json(payload)
}
..........................................***********.......................................
		   CURD - Talking to external third party api
Note:

 if you are write curd operations, if id based code (update,remove,findById)

 src/app/api/todos/[id]/route.js

 if you write curd operations, no parameters (insert,findAll)

 src/app/api/todos/route.js 

...................................................................................
	  Building UI, By consuming Third Party api via route Route Handler
...................................................................................

POST,GETALL
src/app/api/comments/route.js
import { NextResponse } from "next/server"

const url = `https://jsonplaceholder.typicode.com/comments`
export async function GET(request) {
    const response = await fetch(url)
    const comments = await response.json()
    return NextResponse.json(comments)
}
//new comment: POST

export async function POST(request) {
    try {
        const comment = await request.json()
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(comment)
        })
        const newComment = await response.json()

        return new NextResponse(JSON.stringify(newComment), {
            status: 201,
            headers: {
                'Content-Type': 'application/json',
                'url': '/api/create'
            }
        })
    }
    catch (err) {

    }
}

update,delete,findById
src/app/api/comments/[id]/route.js
import { NextResponse } from "next/server"

const url = `https://jsonplaceholder.typicode.com/comments`

//findBy id
export async function GET(request, { params }) {
    const id = (await params).id
    const response = await fetch(`${url}/${id}`)
    const comment = await response.json()
    if (comment.id) {
        return NextResponse.json(comment)
    }

    return NextResponse.json({ message: `Comment for ${id} Not Found` })
}
//update logic

export async function PUT(request, { params }) {

    try {
        const id = (await params).id
        //for we are going to update
        const { name, email, body } = await request.json()
        if (name || email || body) {
            const response = await fetch(`${url}/${parseInt(id)}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ name, email, body })
            })
            if (!response.ok) {
                return new NextResponse(JSON.stringify({ message: `Comment for ${id} Not found` }), {
                    status: 404,
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
            }
            //updatedComment
            const updatedComment = await response.json()
            console.log(updatedComment)
            return NextResponse.json(updatedComment)
        }

    }
    catch (err) {
        return NextResponse.json({ err: err })
    }
}

//delete
export async function DELETE(request, { params }) {
    try {
        const id = (await params).id
        const response = await fetch(`${url}/${parseInt(id)}`, {
            method: 'DELETE'
        })
        const comment  = await response.json()
        console.log(comment)
        if (!response.ok) {
            return new NextResponse(JSON.stringify({ message: `Comment for ${id} Not found` }), {
                status: 404,
                headers: {
                    'Content-Type': 'application/json'
                }
            })
        }
        return NextResponse.json({ message: 'Comment has been deleted' })
    }
    catch (err) {
        return NextResponse.json({ err: err })
    }
}
..............................................................................................
			 Environement variables

In Next.js 18, environment variables are managed using .env files, . Here’s how you can configure and use them effectively:

1. Creating Environment Variables

 Next.js supports three types of .env files:

.env.local  or .env – Used for local development (not committed to Git)

.env.development or .env – Used in development mode (next dev)

.env.production or .env – Used in production mode (next build && next start)

Example .env.local file:

NEXT_PUBLIC_API_URL=https://api.example.com
DATABASE_URL=postgres://user:password@localhost:5432/mydb
SECRET_KEY=supersecretkey

2. Accessing Environment Variables

Public variables (accessible in both frontend & backend): Must be prefixed with NEXT_PUBLIC_

Private variables (only accessible in server-side code): No prefix required

Public Variable Example (Client + Server)

console.log(process.env.NEXT_PUBLIC_API_URL); // Available in the browser
Private Variable Example (Server Only)

export default function handler(req, res) {
  console.log(process.env.SECRET_KEY); // Not exposed to the browser
  res.status(200).json({ message: "Hello World" });
}
3. Loading Environment Variables
Next.js automatically loads environment variables from .env files. However, if you modify them, you need to restart the server (next dev).

4. Using with next.config.js
For variables needed at build time, use next.config.js:

module.exports = {
  env: {
    CUSTOM_KEY: process.env.CUSTOM_KEY,
  },
};
Now, you can access process.env.CUSTOM_KEY in your code.

5. Security Considerations
Never expose secrets in .env without NEXT_PUBLIC_ (it will be bundled in the client)

Use .gitignore to prevent committing .env.local

	.....................................................................................
					Database Integration
....................................................................................
Next js can integrate with any data base including sql (mysql,oracle,postgresql) and no sql (mongo,neodb,redis)

In order to talk to databases, application uses database drivers and apis....

Mostly we use using database frameworks called "ORM- Object Relational Mapping" Framework..

For Node js, We have many frameworks...

1.Prisma
2.Sequelize
3.Type ORM
etc...

In order to work database, we need few things

1.database  - mysql or mssql, or mongo database.

How to setup database?

 1.download database and you have to install
      https://www.postgresql.org/download/windows/
 2.via docker
  
Now a days no body , installing databases directly into machine, rather, we can install via docker.

For training purposes we are going to use "im memory database". You dont need to install database manually either directly or via docker.

In-Memory Databases:
1.sqlite

2.Database drivers
 It is set of js programs to connect with databases, and sending sql statements.


Steps:
1.create project

npx create-next-app@latest
√ What is your project named? ... db-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in E:\IBM\nextjs\apps\db-app.


Step 2: Install Prisma framework.

Before installing prisma framework, we have to decide what database we are going to use.
If you are going to use postgre sql database, then postgresql database must have been installed.

How to install database?  any database

1.download database like postgres
2.install locally

In modern days, we never download database and install, then how to download and install.

Via container technologies like "Docker".

Now i am going to use "inMemory"  database we dont even need docker....

Note:
 In memory databases not for production, or not for real time apps, only for learning purpose...

In Memory Databases:
1.sqllite.
2.H2
etc...

we are going to use sqlite database...

Any database we need to install database dirvers for prisma.


3.Install sqlite database driver
\apps\db-app>npx prisma init --datasource-provider sqlite
Need to install the following packages:
prisma@6.5.0
Ok to proceed? (y) y


✔ Your Prisma schema was created at prisma/schema.prisma
  You can now open it in your favorite editor.

warn You already have a .gitignore file. Don't forget to add `.env` in it to not commit any private information.

Next steps:
1. Set the DATABASE_URL in the .env file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started
2. Run npx prisma db pull to turn your database schema into a Prisma schema.
3. Run npx prisma generate to generate the Prisma Client. You can then start querying your database.
4. Tip: Explore how you can extend the ORM with scalable connection pooling, global caching, and real-time database events. Read: https://pris.ly/cli/beyond-orm

More information in our documentation:
https://pris.ly/d/getting-started

fter installing , you can find folder inside project

projectRootDir/prisma/schema.prisma

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}


ProjectRootDir/".env"
# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

DATABASE_URL="file:./dev.db"
..............................................................................................
....................................................................................
			    ORM Fundamentals
....................................................................................
What is orm?
Object Relational Mapping
 |         |       |
Entity RDBMS    Binding

In Database programs, we use sql query for creating,inserting, updating, deleting

In ORM World, SQL queries are abstracted by apis like save, findAll, findById, remove,update..

Entity Represents a "table" in the database.

Schema :
  The plan or structure

Define Model (Enity)

model User {

}
model Product {

}

Fields:
 Fields are mapped in the table as columns

Syntax:

model ModelName { 
 fieldName Type attributes
}

model Comment{
 id Int @id @default(autoincrement())
 title String
 content String
}

id -  column Name(field)
Int - Datatype
@id -  attribute - Primiary Key
@default - attribute- what is value we are going to assign to primary key
autoincrement - function which generates values...

Where to define this model?

prisma/schema.prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// We have to define model

model User {
  id        String   @id @default(uuid())
  name      String
  email     String
  role      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

Generate tables inside database and create sql query

db-app>npx prisma migrate dev --name init
Environment variables loaded from .env
Prisma schema loaded from prisma\schema.prisma
Datasource "db": SQLite database "dev.db" at "file:./dev.db"

SQLite database dev.db created at file:./dev.db

Applying migration `20250217072911_init`

The following migration(s) have been created and applied from new schema changes:

migrations/
  └─ 20250217072911_init/
    └─ migration.sql

Your database is now in sync with your schema.

Running generate... (Use --skip-generate to skip the generators)

✔ Generated Prisma Client (v6.3.1) to .\node_modules\@prisma\client in 46ms

AFter running this step, you can see the table structure


migrations/
  └─ 20240311072557_init/
    └─ migration.sql
-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "role" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

Testing whether database tables are created or not
npx prisma studio

.....................................................................................
				Prisma Client api
.....................................................................................
Prisma Client api is used to talk database from rest apis.

src/lib/prisma.js
//Prisma client api 
import { PrismaClient } from "@prisma/client";
const globalForPrisma = global
export const prisma = globalForPrisma.prisma || new PrismaClient({ log: ["query"] })
.....................................................................................						REST API with Prisma
................................................................................

src/app/api/users/route.js



//write rest api which talks to database via prisma client

import { prisma } from "@/app/lib/prisma";
import { NextResponse } from "next/server";


export async function GET(request) {
    //connect to prisma 
    const users = await prisma.user.findMany()
    return NextResponse.json(users)
}

// create
export async function POST(request) {
    try {
        const user = await request.json()
        const response = await prisma.user.create({
            data: user
        })
        return new NextResponse(JSON.stringify(response), {
            status: 201,
            headers: {
                "Content-Type": "application/json"
            }
        })
    }
    catch (err) {
        return NextResponse.json(err)
    }
}

findById,update,delete

src/app/api/users/[id]/route.js
import { prisma } from "@/app/lib/prisma"
import { NextResponse } from "next/server"

export async function GET(request, { params }) {
    try {
        const id = (await params).id
        const users = await prisma.user.findUnique({
            where: {
                id: id
            }
        })
        if (!users) {
            return NextResponse.json({ message: "UserNot Found", code: 404 })
        }
        return NextResponse.json(users)
    }
    catch (err) {
        return NextResponse.json(err)
    }

}

//update
export async function PUT(request, { params }) {
    try {
        const id = (await params).id
        const payload = await request.json()
        const user = await prisma.user.update({
            where: {
                id
            },
            data: payload
        })
        if (!user) {
            return NextResponse.json({ message: `No user found with ${id}`, code: 404 })
        }
        return NextResponse.json(user)
    }
    catch (err) {
        return NextResponse.json(err)

    }
}

//remove
export async function DELETE(request, { params }) {
    try {
        const id = (await params).id
        await prisma.user.delete({
            where: {
                id
            }
        })
        return new NextResponse(null, { status: 404 })
    }
    catch (err) {
        return NextResponse.json(err)


    }
}
............................................................................................
			Data base integration with User interface
...........................................................................................

export default async function UsersPage() {
    const users = await getUsers()
    return <main>
        <ul>
            {
                users.map(user => {
                    return <li>
                        <span>{user.id} -  {user.name}</span>
                    </li>
                })
            }
        </ul>
    </main>

}
............................................................................................
			Data base integration with User interface
...........................................................................................

export default async function UsersPage() {
    const users = await getUsers()
    return <main>
        <ul>
            {
                users.map(user => {
                    return <li>
                        <span>{user.id} -  {user.name}</span>
                    </li>
                })
            }
        </ul>
    </main>

}

CURD:


src/app/users/components/users.jsx

'use client'
import { useState, useEffect } from 'react';

export function User() {
    const [users, setUsers] = useState([]);
    const [formData, setFormData] = useState({ id: '', name: '', email: '', role: '' });
    const [isEditing, setIsEditing] = useState(false);


    useEffect(() => {
        fetch('http://localhost:3000/api/users')
            .then((res) => res.json())
            .then((data) => setUsers(data));
    }, []);


    const handleEdit = (user) => {
        setFormData(user);
        setIsEditing(true);
    };

    const handleSubmit = async (e) => {
        e.preventDefault();

        if (isEditing) {
            // Update user
            const res = await fetch(`http://localhost:3000/api/users/${formData.id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: formData.name, email: formData.email, role: formData.role }),
            });

            if (res.ok) {
                const updatedUser = await res.json();
                setUsers((prev) => prev.map((user) => (user.id === updatedUser.id ? updatedUser : user)));
            }
            setIsEditing(false);
        } else {
            // Create new user
            const res = await fetch('http://localhost:3000/api/users', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: formData.name, email: formData.email, role: formData.role }),
            });

            if (res.ok) {
                const newUser = await res.json();
                setUsers((prev) => [...prev, newUser]);
            }
        }

        setFormData({ id: '', name: '', email: '', role: '' });
    };
    const handleDelete = async (id) => {
        const res = await fetch(`http://localhost:3000/api/users/${id}`, {
            method: 'DELETE',
        });

        if (res.ok) {
            setUsers((prev) => prev.filter((user) => user.id !== id));
        }
    };

    return (
        <div>
            <h1 style={{textAlign:'center',fontSize:'35px'}}>User Management</h1>
            <form onSubmit={handleSubmit}>
                <div>
                    <input
                        type="text"
                        placeholder="Name"
                        value={formData.name}
                        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                        required
                    />
                </div>
                <input
                    type="email"
                    placeholder="Email"
                    value={formData.email}
                    onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                    required
                />
                <input
                    type="text"
                    placeholder="Role"
                    value={formData.role}
                    onChange={(e) => setFormData({ ...formData, role: e.target.value })}
                    required
                />
                <button type="submit">{isEditing ? 'Update User' : 'Add User'}</button>
            </form>
            <ul>
                {users.map((user) => (
                    <li key={user.id}>
                        <div className="user-details">
                            <span>
                                {user.name} ({user.email}) - {user.role}
                            </span>
                        </div>
                        <div className="actions">
                            <button onClick={() => handleEdit(user)}>Edit</button>
                            <button onClick={() => handleDelete(user.id)}>Delete</button>
                        </div>
                    </li>
                ))}
            </ul>

        </div>
    );
}
src/users/page.js
import { Users } from "./components/users";

export default function UsersPage(){

    return <Users/>
}

global.css
/* @tailwind base;
@tailwind components;
@tailwind utilities; */

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  margin: 100px;
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}
form {
  max-width: 500px;
  margin: 20px auto;
  padding: 20px;
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

form input {
  width: calc(100% - 20px);
  margin-bottom: 15px;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
}

form button {
  width: 100%;
  padding: 10px;
  background-color: #0070f3;
  color: #fff;
  border: none;
  border-radius: 4px;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

form button:hover {
  background-color: #005bb5;
}

ul {
  list-style: none;
  padding: 0;
  max-width: 600px;
  margin: 20px auto;
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

li {
  padding: 15px;
  border-bottom: 1px solid #eee;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

li:last-child {
  border-bottom: none;
}

li .user-details {
  flex-grow: 1; /* Allow the user details to take all available space */
}

li .actions {
  display: flex;
  gap: 10px;
  justify-content: flex-end; /* Ensure buttons are aligned to the right */
}

button {
  padding: 5px 10px;
  background-color: #f44336;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s ease;
}

button:hover {
  background-color: #d32f2f;
}

button:first-of-type {
  background-color: #4caf50;
}

button:first-of-type:hover {
  background-color: #388e3c;
}











